{
  "hash": "be361bfd1d7262c6ab8ecd9b02b4d643",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Joining Data\"\ndescription: \"Join multiple datasets together based on similar or different values of a column. e.g. join environmental and species data based on site name\"\nauthor: \"Mitchell Stares\"\nweight: 14\ndate: '2018-11-09'\noutput: blogdown::html_page\neditor_options:\n  chunk_output_type: console\n---\n\n\n\n::: {.cell}\n\n:::\n\n\n\nOne of the most frequent data manipulations for working within R is joining multiple data sets together. The most common example of this is combining species abundance (or some other variable of interest) with external sources on the environmental conditions, such as BOM data (temperature, precipitation etc.) or GPS data.  \n\nTo do most statistical analyses, data needs to be in the same data frame. So joining the datasets is an \"easy\" way to do so outside of excel.  \n\n::: callout\nFor this exercise, we will be working with the BIOL365 Frog Data to combine the species matrix with environmental data.  \n**Download the \"frogs.csv\" and \"frog_environmental.csv\"\" files and read them in to R without the row.names argument**\n::: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfrogsp<-read.csv(\"frogs.csv\", header=TRUE)\nenviro<-read.csv(\"frog_environmental.csv\", header=TRUE)\n```\n:::\n\n\n\nFor a complete join of both datasets, when there are the same number of rows in the exact same order, we can use the `bind_cols()` function. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nfrogcombine <- bind_cols(frogsp, enviro) # In this example the \"site\" column has been added twice\n```\n:::\n\n\nThere is a `bind_rows()` that will add rows to the bottom of a dataset, using the same syntax.  \n\nWhile `bind_cols()` and `bind_rows()` are \"cool\", they are limited in their usefulness. I find the most useful function is `left_join()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfrogjoin <- left_join(frogsp, enviro, by=\"Site\") # This will join two datasets by a similar column (Site). \n```\n:::\n\n\nThis will join the second dataset (enviro) to the first data set based on the shared column. `right_join()` will do the opposite, joining frogsp to enviro. Its pretty useless, just use `left_join()` remember to always put the data frame you want to keep first. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# We can use the dim() to view the dimensions of the data\ndim(frogsp) # 11 columns\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 42 11\n```\n\n\n:::\n\n```{.r .cell-code}\ndim(enviro) # 16 columns\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 42 16\n```\n\n\n:::\n\n```{.r .cell-code}\ndim(frogjoin) # 26 colums (11 + 16 minus the 1 in common)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 42 26\n```\n\n\n:::\n:::\n\n\n\nBoth of these examples so far have required the same rows for each dataset. Sometimes we might have more information in one dataset then we do in the other. For this dataset we don't have this issue, so lets quickly create the issue to demonstrate.  \n\nWe will simply use the `filter()` command to filter for rows that contain a value in the \"Temp\" column. We have 4 rows that have an NA in \"Temp\" so we will use a != (not equal to) to select all rows that are not equal to NA\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nenviro_filter <- filter(enviro, Temp != \"NA\") # This removes sites 14, 15, 35 & 36\ndim(enviro_filter)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 38 16\n```\n\n\n:::\n\n```{.r .cell-code}\n# Now we can try the two new join types\n\nfroginner <- inner_join(frogsp, enviro_filter, by=\"Site\") # Join data. Retain only rows that occur in both data sets\ndim(froginner) # 38 rows\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 38 26\n```\n\n\n:::\n\n```{.r .cell-code}\nfrogfull <- full_join(frogsp, enviro_filter, by=\"Site\") # Join data. Retain all values, all rows\ndim(frogfull)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 42 26\n```\n\n\n:::\n:::\n\n\n\nYou can also use **semi_join()** to combine all rows that have a match in the second dataset, or **anti_join()** to combine all rows that do not match have a match in the second dataset (this ones a little weird). \n\nI still find myself using `left_join` 90% of the time though. ",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}